import os, sys
from pathlib import Path

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import matplotlib.patches as patches

try:
    from data_handle.sid_object import *
except:
    sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
    from data_handle.sid_object import *

'''
There are 3 kinds of folder structure:
1. [1c] data_dir - obj
2. [2c] data_dir - obj - obj&env (each object has its own environment)
3. [2c] data_dir - obj&env       (all objects share one environment)
(2 & 3 is compatible with 1 to some extent)

Functions 'gen_csv_trackers' and 'gather_all_data' are universal.
They only depend on the data structure version.
'''

def gen_csv_trackers(data_dir, channel_per_image=2): # Data structure 2
    # data_dir - obj - obj&env (each object has its own environment)
    cpi = channel_per_image
    obj_folders = os.listdir(data_dir)
    for objf in obj_folders:
        if cpi == 1:
            obj_files = os.listdir(os.path.join(data_dir, objf)) # all files/images under this folder
        else:
            obj_files = os.listdir(os.path.join(data_dir, objf, 'obj')) # all files/images under this folder
        t_list = []   # time or time step
        x_list = []   # x coordinate
        y_list = []   # y coordinate
        idx_list = [] # more information (e.g. scene index)
        invalid_files = []
        for f in obj_files:
            info = f[:-4] # the last for characters are filename extensions
            try:
                t_list.append(int(info.split('_')[1]))
                x_list.append(float(info.split('_')[2]))
                y_list.append(float(info.split('_')[3]))
                idx_list.append(int(info.split('_')[4]))
            except:
                invalid_files.append(f)
                continue
        for f in invalid_files:
            obj_files.remove(f)
        df = pd.DataFrame({'f':obj_files,'t':t_list,'x':x_list,'y':y_list, 'index':idx_list}).sort_values(by='t', ignore_index=True)
        if cpi == 1:
            df.to_csv(os.path.join(data_dir, objf, '/data.csv'), index=False)
        else:
            df.to_csv(os.path.join(data_dir, objf, 'obj/data.csv'), index=False)

def gather_all_data(data_dir, past, maxT, channel_per_image=1, minT=1, period=1, save_dir=None): # Data structure 2
    # data_dir  -  objf(1,2,...) - obj&env
    if save_dir is None:
        save_dir = data_dir
    cpi = channel_per_image

    column_name = [f'f{i}' for i in range(0,cpi*(past+1))] + ['T', 'x', 'y', 'index']
    df_all = pd.DataFrame(columns=column_name)
    obj_folders = os.listdir(data_dir)
    cnt = 0
    for objf in obj_folders:
        cnt += 1
        print(f'\rProcess {cnt}/{len(obj_folders)}', end='    ')
        df_obj = pd.read_csv(os.path.join(data_dir, objf, 'obj/data.csv')) # generated by "gen_csv_trackers"
        for T in range(minT,maxT+1):
            sample_list = []
            for i in range(len(df_obj)-past*period-T): # each sample
                sample = []
                ################## Sample START ##################
                for j in range(past+1):
                    obj_filename = df_obj.iloc[i+j*period]['f']
                    sample.append(obj_filename)
                    if cpi == 2:
                        sample.append(obj_filename.split('_')[0]+'_'+obj_filename.split('_')[1]+'_'+obj_filename.split('_')[-1])
                sample.append(T)
                sample.append(df_obj.iloc[i+past+T]['x'])
                sample.append(df_obj.iloc[i+past+T]['y'])
                sample.append(df_obj.iloc[i+past+T]['index'])
                ################## Sample E N D ##################
                sample_list.append(sample)
            df_T = pd.DataFrame(sample_list, columns=df_all.columns)
            df_all = pd.concat([df_all, df_T], ignore_index=True)
    df_all.to_csv(os.path.join(save_dir, 'all_data.csv'), index=False)


def index2map(index):
    # index: [map_idx, path_idx, interact]
    assert (12>=index>=1),("Index must be an integer from 1 to 12.")
    map_dict = {1:[1,1,False], 2:[1,1,True],
                3:[1,2,False], 4:[1,2,True],
                5:[1,3,False], 6:[1,3,True],

                7: [2,1,False], 8: [2,1,True],
                9: [2,2,False], 10:[2,2,True],
                11:[2,3,False], 12:[2,3,True]
                }
    return map_dict[index]

def save_SID_data(index_list, save_path, sim_time_per_scene:int, channel_per_image=1, dots_per_inch=None):
    # SID - Single-target Interaction Dataset
    cpi = channel_per_image
    dpi = dots_per_inch

    cnt = 0
    overall_sim_time = sim_time_per_scene * len(index_list)
    for idx in index_list:
        map_idx, path_idx, interact = index2map(idx) # map parameters
        stagger, vmax, target_size, ts = (0.2, 1, 0.5, 0.2) # object parameters

        graph = Graph(map=map_idx, block=False)
        path  = graph.get_path(path_idx)
        if interact:
            dyn_obs_path = graph.get_obs_path(ts)
        else:
            dyn_obs_path = [(-1,-1)]

        for i in range(sim_time_per_scene):
            cnt += 1
            print(f'\rSimulating: {cnt}/{overall_sim_time}', end='   ')

            obj = MovingObject(path[0], stagger)
            obj.run(path, ts, vmax, dyn_obs_path=dyn_obs_path)
            for j, tr in enumerate(obj.traj):
                shape = patches.Circle(tr, radius=target_size/2, fc='k')
                try:
                    obs_shape = patches.Circle(dyn_obs_path[j], radius=target_size/2, fc='k')
                except:
                    obs_shape = patches.Circle(dyn_obs_path[-1], radius=target_size/2, fc='k')

                if cpi == 1:
                    # images containing everything
                    _, ax = plt.subplots(dpi=dpi)
                    graph.plot_map(ax, clean=True) ### NOTE change this
                    ax.add_patch(shape)
                    ax.set_aspect('equal', 'box')
                    ax.axis('off')
                    if save_path is None:
                        plt.show()
                    else:
                        folder = os.path.join(save_path,f'{cnt}/')
                        Path(folder).mkdir(parents=True, exist_ok=True)
                        plt.savefig(os.path.join(folder,f'{cnt}_{j}_{round(tr[0],4)}_{round(tr[1],4)}_{idx}.png'), 
                                    bbox_inches='tight', pad_inches=0, dpi=dpi)
                        plt.close()
                elif cpi == 2:
                    # images containing only object
                    _, ax1 = plt.subplots(dpi=dpi)
                    graph.plot_map(ax1, empty=True) ### NOTE change this
                    ax1.add_patch(shape)
                    ax1.set_aspect('equal', 'box')
                    ax1.axis('off')
                    if save_path is None:
                        plt.show()
                    else:
                        folder = os.path.join(save_path,f'{cnt}/obj')
                        Path(folder).mkdir(parents=True, exist_ok=True)
                        plt.savefig(os.path.join(folder,f'{cnt}_{j}_{round(tr[0],4)}_{round(tr[1],4)}_{idx}.png'), 
                                    bbox_inches='tight', pad_inches=0, dpi=dpi)
                        plt.close()
                    # images containing env
                    _, ax2 = plt.subplots(dpi=dpi)
                    graph.plot_map(ax2, clean=True) ### NOTE change this
                    ax2.add_patch(obs_shape)
                    ax2.set_aspect('equal', 'box')
                    ax2.axis('off')
                    if save_path is None:
                        plt.show()
                    else:
                        folder = os.path.join(save_path,f'{cnt}/env')
                        Path(folder).mkdir(parents=True, exist_ok=True)
                        plt.savefig(os.path.join(folder,f'{cnt}_{j}_{idx}.png'), 
                                    bbox_inches='tight', pad_inches=0, dpi=dpi)
                        plt.close()

                else:
                    raise(ModuleNotFoundError('CPI must be 1 or 2.'))

    print()